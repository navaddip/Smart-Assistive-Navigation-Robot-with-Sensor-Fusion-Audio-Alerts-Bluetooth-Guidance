import RPi.GPIO as GPIO
import time
import pigpio
import serial

# GPIO Pins for motor, sensors, servo
TRIG = 23      # Ultrasonic TRIG
ECHO = 24      # Ultrasonic ECHO
SERVO = 17     # Servo control
PLAYE_PIN = 25 # ISD1820 Playback pin

# Motor Driver Pins (L298N)
ENA = 4
IN1 = 5
IN2 = 6
IN3 = 13
IN4 = 19
ENB = 9

# Bluetooth Config
BLUETOOTH_PORT = "/dev/serial0"
bluetooth = serial.Serial(BLUETOOTH_PORT, baudrate=9600, timeout=1)

# GPIO Setup
GPIO.setmode(GPIO.BCM)
GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)
GPIO.setup(SERVO, GPIO.OUT)
GPIO.setup(PLAYE_PIN, GPIO.OUT)
GPIO.setup([IN1, IN2, IN3, IN4], GPIO.OUT)
GPIO.setup([ENA, ENB], GPIO.OUT)
GPIO.output(ENA, True)
GPIO.output(ENB, True)
motorA_pwm = GPIO.PWM(ENA, 100)  # 100 Hz PWM
motorB_pwm = GPIO.PWM(ENB, 100)
motorA_pwm.start(0)
motorB_pwm.start(0)

# pigpio for servo
pi = pigpio.pi()
if not pi.connected:
    exit()

# Servo angle function
def set_angle(angle):
    pulse_width = 500 + (angle * 2000 / 180)
    pi.set_servo_pulsewidth(SERVO, pulse_width)
    time.sleep(0.5)

# Ultrasonic distance function
def get_distance():
    GPIO.output(TRIG, True)
    time.sleep(0.00001)
    GPIO.output(TRIG, False)
    start_time, stop_time = time.time(), time.time()
    while GPIO.input(ECHO) == 0:
        start_time = time.time()
    while GPIO.input(ECHO) == 1:
        stop_time = time.time()
    elapsed = stop_time - start_time
    distance = (elapsed * 34300) / 2
    return round(distance, 2)

# Motor movement functions
def move_forward(speed=50):
    GPIO.output(IN1, True)
    GPIO.output(IN2, False)
    GPIO.output(IN3, True)
    GPIO.output(IN4, False)
    motorA_pwm.ChangeDutyCycle(speed)
    motorB_pwm.ChangeDutyCycle(speed)

def move_backward(speed=50):
    GPIO.output(IN1, False)
    GPIO.output(IN2, True)
    GPIO.output(IN3, False)
    GPIO.output(IN4, True)
    motorA_pwm.ChangeDutyCycle(speed)
    motorB_pwm.ChangeDutyCycle(speed)

def turn_left(speed=50):
    GPIO.output(IN1, False)
    GPIO.output(IN2, True)
    GPIO.output(IN3, True)
    GPIO.output(IN4, False)
    motorA_pwm.ChangeDutyCycle(speed)
    motorB_pwm.ChangeDutyCycle(speed)

def turn_right(speed=50):
    GPIO.output(IN1, True)
    GPIO.output(IN2, False)
    GPIO.output(IN3, False)
    GPIO.output(IN4, True)
    motorA_pwm.ChangeDutyCycle(speed)
    motorB_pwm.ChangeDutyCycle(speed)

def stop_motors():
    motorA_pwm.ChangeDutyCycle(0)
    motorB_pwm.ChangeDutyCycle(0)
    GPIO.output([IN1, IN2, IN3, IN4], False)

# Playback ISD1820 voice module
def play_voice():
    GPIO.output(PLAYE_PIN, True)
    time.sleep(2)
    GPIO.output(PLAYE_PIN, False)
    print("Played ISD1820 voice reminder.")

# Bluetooth send
def send_bluetooth_command(command):
    bluetooth.write(command.encode())
    print(f'Bluetooth Command Sent: {command}')

# Main obstacle avoidance + special feature loop
def obstacle_avoidance():
    try:
        while True:
            set_angle(90)
            distance = get_distance()
            print(f"Front Distance: {distance} cm")
            if distance < 15:
                print("Obstacle detected! Stopping, playing audio, and sending BT command.")
                stop_motors()
                play_voice()
                send_bluetooth_command("Obstacle detected! Turning.\n")
                time.sleep(0.5)

                set_angle(150)
                left_distance = get_distance()
                print(f"Left Distance: {left_distance} cm")

                set_angle(30)
                right_distance = get_distance()
                print(f"Right Distance: {right_distance} cm")

                if left_distance > right_distance:
                    print("Turning Left")
                    turn_left()
                    time.sleep(1)
                else:
                    print("Turning Right")
                    turn_right()
                    time.sleep(1)
                stop_motors()
                time.sleep(0.5)
            else:
                move_forward()
                time.sleep(0.1)
    except KeyboardInterrupt:
        print("\nExiting...")
    finally:
        stop_motors()
        pi.set_servo_pulsewidth(SERVO, 0)
        pi.stop()
        GPIO.cleanup()

# Run the new combined robot logic
obstacle_avoidance()